<!--@license MIT License Copyright (c) 2014 Aleks Totic -->

<link rel="import" href="../core-drawer-panel/core-drawer-panel.html">
<link rel="import" href="../core-header-panel/core-header-panel.html">
<link rel="import" href="../core-ajax/core-ajax.html">

<link rel="import" href="elements/fancy-doc-toc.html">
<link rel="import" href="elements/fancy-doc-page.html">

<!--
Polymer-style docs for your site.

Displays documentation for your own elements, and all elements
imported via bower.


### Included

- viewer for polymer elements, markdown docs, and txt files
- easy setup, with sourceSetTask.js setup script

### Installation

bower install fancy-doc-viewer --save-dev

### Usage

`fancy-doc-viewer` displays docs hosted on your server.

1) all the doc files need to be reachable by the browser. For me
that meant moving my docs directory inside www.

2) create a file to host `fancy-doc-viewer`. I suggest `index.html` inside your docs directory:

      <!doctype html>
      <html>
      <head>
        <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0">
        <title>documentation</title>
        <script src="../webcomponentsjs/webcomponents.min.js"></script>
        <link rel="import" href="../core-ajax/core-ajax.html">
        <link rel="import" href="../fancy-doc-viewer.html">
      </head>
      <body>
        <template id="auto" is="auto-binding" sourceSet="{{sourceSet}}">
          <core-ajax auto url="sourceSet.json" response="{{sourceSet}}"></core-ajax>
          <fancy-doc-viewer sourceSet="{{sourceSet}}"></fancy-doc-viewer>
        </template>
      </body>
      </html>

3) Create a configuration file listing all the documents. The format is json:

      {
        menuName: [ url*],
        menuName2: [ url *]
      }
      
Example:

      {
        Documents: ["README.md", "docs/TODO.txt"],
        Elements: ["fancy-doc-viewer.html", "elements/fancy-doc-page.html", "elements/fancy-doc-toc.html" ],
        Tests: [ "test/index.html"],
        Bower: [ "../core-drawer-panel/core-drawer-panel.html"...]
      }

I suggest creating this file with a task. See starter tast at [sourceSetTask.js](sourceSetTask.js)

Some menu names are magic:

HTML files inside Documents menu will be interpreted as HTML.
HTML files everywhere else will be parsed as polymer-elements.

Save your configuration file `sourceSet.json` inside docs directory next to your index.html.

4) Load docs/index.html, and smile.

@element fancy-doc-viewer
@blurb Polymer-style docs for your own site
@status alpha
@homepage http://github.com/atotic/fancy-doc-viewer
-->
<script src="../context-free-parser/context-free-parser.js"></script>
<polymer-element name="fancy-doc-viewer" attributes="sourceSet" horizontal layout>

  <template>
    <link rel="stylesheet" href="fancy-doc-viewer.css">
    <core-drawer-panel id="drawerPanel" drawerWidth="16em">
      <core-header-panel drawer>
        <div id="logo" layout horizontal>
          <div flex self-center layout horizontal center-justified >
            <core-icon src="/favicon.ico" alt="" ></core-icon>
          </div>
        </div>
        <fancy-doc-toc hierarchy="{{hierarchy}}"></fancy-doc-toc>
      </core-header-panel>
      <core-header-panel main>
        <core-toolbar>
          <core-icon id="navicon" icon="menu" 
            on-tap="{{toggleDrawer}}" 
            style="display:{{$.drawerPanel.narrow ? 'inline-block' : 'none'}}"
          ></core-icon>
          <core-item label="documentation"></core-item>
        </core-toolbar>
        <fancy-doc-page 
          mimeType="{{urlDataMap[ hashUrlMap [ route]].mimeType}}" 
          data="{{urlDataMap[ hashUrlMap[ route] ].data}}"
          url="{{hashUrlMap[route]}}"
        >
        </fancy-doc-page>
      </core-header-panel>
    </core-drawer-panel>
    <!-- resource loading -->
    <template repeat="{{ k in keys(hashUrlMap)}}">
      <core-ajax auto url="{{ hashUrlMap[k] }}" on-core-complete="{{docLoaded}}"></core-ajax>
    </template>
  </template>

  <script>
    "use strict";
    Polymer({
      /**
       * Hierarchical list of documentation files. Use sourceSetTask.js to generate.
       @attribute sourceSet
       @type object
       @example 
<pre>{
Documents: ["README.md", "docs/TODO.txt"],
Elements: ["fancy-doc-viewer.html", "elements/fancy-doc-page.html", "elements/fancy-doc-toc.html" ],
Tests: [ "test/index.html"],
Bower: [ "../core-drawer-panel/core-drawer-panel.html"...]
}</pre>
      */
      sourceSet: {
        pleaseDefineSourceSet: [],
        general: [],
        elements: [],
        tests: [],
        bower: []
      },
      hashUrlMap: {}, // core-ajax loads data from this map
      urlDataMap: {}, // url -> { mimeType: "", data: ""}
      plainHtmlUrls: {}, // url -> true, list of html elements that should not be treated as html
      computed: {
        hierarchy: 'computeHierarchy(sourceSet)',
        routeMimeType: 'computeRouteMimeType( urlDataMap[ hashUrlMap[route]].mimeType)'
      },

      ready: function() {
        window.addEventListener('hashchange', this.parseLocationHash.bind(this));
        this.parseLocationHash();
      },

      toggleDrawer: function() {
        this.$.drawerPanel.togglePanel();
      },

      keys: function(input) {
        return Object.keys(input);
      },

      parseLocationHash: function() {
        this.route = window.location.hash;
        // hack: hashes auto-generated by core-doc-page do not have .html, monkeypatches it
        if (!(this.route in this.hashUrlMap)  
          && ((this.route + ".html") in this.hashUrlMap))
          window.location.hash = this.route + ".html";
      },

      computeRouteMimeType: function(mimeType) {
        switch(mimeType) {
          case "text/html":
          case "text/html;content-disposition:polymer":
          case "text/x-markdown":
          case "text/plain":
            return mimeType;
          case "":
            return "blank";
          default:
            return "unknown";
        }
      },
      computeHierarchy: function(sourceSet) {
        var hierarchy = {};
        this.hashUrlMap = {};
        for (var k in sourceSet) {
          hierarchy[k] = [];
          sourceSet[k].forEach( function(url) {
            var baseName = url.substring(url.lastIndexOf('/')+1);
            var name = baseName.substring(0, baseName.lastIndexOf('.'));
            var href;
            if (k.match(/^test/i)) {
             // WCT cant run in iframe, tests are opened in new window
              href = url;
            }
            else {
              href = "#" + baseName;
              if (href in this.hashUrlMap) {// hash colision, pick a new one
                var i=1, newHref = href;
                while (newHref in this.hashUrlMap)
                  newHref = href + i;
                href = newHref;
              }
              this.hashUrlMap[href] = url;
              if ( k.match(/^docu/i))
                this.plainHtmlUrls[url] = true;
              if (!window.location.hash)
                window.location.hash = href.substring(1);
            }
            hierarchy[k].push({ name: name, href: href});
          }.bind(this));
          if (hierarchy[k].length == 0)
            delete hierarchy[k];
        }
        return hierarchy;
      },

      // docs loaded by ajax
      docLoaded: function(ev) {
        var url = ev.target.url;
        if (ev.detail.response !== 200) {
          this.urlDataMap[ url ] = {
            mimeType: 'text/plain',
            data: "url " + url + " could not be loaded. HTTP: " + ev.detail.response
          };
        }
        else {
          var mimeType = ev.detail.xhr.getResponseHeader('Content-Type');
          mimeType = mimeType.substring(0, mimeType.lastIndexOf(';'));
          var data = ev.detail.xhr.responseText;

          if (mimeType === "text/html" && !(url in this.plainHtmlUrls)) {
            data = this.processPolymerDoc( data, url);
            data = data.classes[0];
            mimeType = "text/html;content-disposition:polymer"
          }

          this.urlDataMap[ url ] = {
            mimeType: mimeType,
            data: data
          }
        }
      },
      // Code lifted from context-free-parser.html
      processPolymerDoc: function(data,url) {
        var entities = ContextFreeParser.parse(data);
        if (!entities || entities.length === 0) {
          entities = [
            {name: url.substring(url.lastIndexOf('/')+1), 
            description: '**Undocumented**'}
          ];
        }
        return { classes: entities };
      }

    });

    PolymerExpressions.prototype.capitalize = function(input) {
      return Object.keys(input);
    };
  </script>

</polymer-element>
